# AlmaLinux Custom ISO Creator with Embedded Kickstart Parameters
# This script creates a custom AlmaLinux ISO with kickstart parameters embedded
# to enable fully automated installation without manual intervention.
#
# FEATURES:
# - Extracts original AlmaLinux ISO
# - Modifies boot configuration to include kickstart parameters
# - Embeds kickstart file directly into the ISO
# - Creates customized ISO for both Gen 1 and Gen 2 VMs
# - Supports both BIOS and UEFI boot modes
#
# USAGE:
#   .\create-custom-iso.ps1 [-KickstartVersion v1|v2] [-Generation 1|2]
#

param(
    [Parameter(Mandatory=$false)]
    [ValidateSet("v1", "v2")]
    [string]$KickstartVersion = "v1",
    
    [Parameter(Mandatory=$false)]
    [ValidateSet(1, 2)]
    [int]$Generation = 2
)

# Load configuration
$configPath = Join-Path $PSScriptRoot "config.yaml"
if (-not (Test-Path $configPath)) {
    Write-Error "Configuration file not found: $configPath"
    exit 1
}

# Simple YAML parser (reusing from provision-vms.ps1)
function ConvertFrom-Yaml {
    param([string]$YamlContent)
    
    $config = @{}
    $lines = $YamlContent -split "`n" | Where-Object { $_ -match '^\s*\w+:' }
    
    foreach ($line in $lines) {
        if ($line -match '^\s*([^:]+):\s*"?([^"]+)"?\s*$') {
            $key = $matches[1].Trim()
            $value = $matches[2].Trim().Trim('"')
            
            if ($value -match '^\d+$') {
                $config[$key] = [int]$value
            }
            elseif ($value -match '^(\d+)(GB|MB|KB)$') {
                $size = [int]$matches[1]
                $unit = $matches[2]
                switch ($unit) {
                    "KB" { $config[$key] = $size * 1KB }
                    "MB" { $config[$key] = $size * 1MB }
                    "GB" { $config[$key] = $size * 1GB }
                }
            }
            else {
                $config[$key] = $value
            }
        }
    }
    return $config
}

$yamlContent = Get-Content $configPath -Raw
$config = ConvertFrom-Yaml -YamlContent $yamlContent

# Configuration
$originalISO = $config["iso_path"]
$outputDir = Join-Path (Split-Path $PSScriptRoot) "custom-iso"
$customISOName = "AlmaLinux-$KickstartVersion-Gen$Generation-Custom.iso"
$customISO = Join-Path $outputDir $customISOName
$workDir = Join-Path $env:TEMP "alma-iso-custom"
$extractDir = Join-Path $workDir "extracted"
$kickstartFile = Join-Path $PSScriptRoot "..\templates\AlmaLinux\$KickstartVersion\ks.cfg"

# Validate inputs
if (-not (Test-Path $originalISO)) {
    Write-Error "Original AlmaLinux ISO not found: $originalISO"
    exit 1
}

if (-not (Test-Path $kickstartFile)) {
    Write-Error "Kickstart file not found: $kickstartFile"
    exit 1
}

# Function to install Windows ADK silently
function Install-WindowsADK {
    Write-Host "Windows ADK not found. Installing automatically..."
    
    # Download ADK installer
    $adkUrl = "https://go.microsoft.com/fwlink/?linkid=2243390"  # Latest ADK for Windows 11 version 22H2
    $adkInstaller = Join-Path $env:TEMP "adksetup.exe"
    
    try {
        Write-Host "Downloading Windows ADK installer..."
        Invoke-WebRequest -Uri $adkUrl -OutFile $adkInstaller -UseBasicParsing
        
        Write-Host "Installing Windows ADK (Deployment Tools only)..."
        Write-Host "This may take several minutes. Please wait..."
        
        # Install ADK with only Deployment Tools feature (silent install)
        $installArgs = @(
            "/quiet"
            "/norestart"
            "/features"
            "OptionId.DeploymentTools"
        )
        
        $process = Start-Process -FilePath $adkInstaller -ArgumentList $installArgs -Wait -PassThru
        
        if ($process.ExitCode -eq 0) {
            Write-Host "Windows ADK installed successfully!"
            # Remove installer
            Remove-Item $adkInstaller -Force -ErrorAction SilentlyContinue
            return $true
        } else {
            Write-Error "Windows ADK installation failed with exit code: $($process.ExitCode)"
            return $false
        }
        
    } catch {
        Write-Error "Failed to download or install Windows ADK: $($_.Exception.Message)"
        return $false
    } finally {
        # Cleanup installer file
        if (Test-Path $adkInstaller) {
            Remove-Item $adkInstaller -Force -ErrorAction SilentlyContinue
        }
    }
}

# Check for required tools and install if needed
$oscdimgPath = "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe"
if (-not (Test-Path $oscdimgPath)) {
    Write-Host "oscdimg.exe not found at: $oscdimgPath"
    
    # Try alternative locations for different ADK versions
    $alternativePaths = @(
        "${env:ProgramFiles(x86)}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe",
        "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\amd64\Oscdimg\oscdimg.exe",
        "${env:ProgramFiles}\Windows Kits\10\Assessment and Deployment Kit\Deployment Tools\x86\Oscdimg\oscdimg.exe"
    )
    
    $found = $false
    foreach ($altPath in $alternativePaths) {
        if (Test-Path $altPath) {
            $oscdimgPath = $altPath
            $found = $true
            Write-Host "Found oscdimg.exe at: $oscdimgPath"
            break
        }
    }
    
    if (-not $found) {
        Write-Host "Windows ADK (Assessment and Deployment Kit) is required but not installed."
        
        # Check if running as administrator
        $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
        $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
        $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        
        if (-not $isAdmin) {
            Write-Error "Administrator privileges required to install Windows ADK automatically."
            Write-Host "Please run PowerShell as Administrator, or install Windows ADK manually:"
            Write-Host "Download from: https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install"
            Write-Host "Only the 'Deployment Tools' component is required."
            exit 1
        }
        
        # Ask user for permission to install
        $response = Read-Host "Would you like to install Windows ADK automatically? (Y/N)"
        
        if ($response -match "^[Yy]") {
            if (Install-WindowsADK) {
                # Re-check for oscdimg.exe after installation
                if (Test-Path $oscdimgPath) {
                    Write-Host "Windows ADK installation successful. Continuing with ISO creation..."
                } else {
                    Write-Error "oscdimg.exe still not found after ADK installation. Please check the installation."
                    exit 1
                }
            } else {
                Write-Error "Windows ADK installation failed. Cannot continue."
                exit 1
            }
        } else {
            Write-Error "Windows ADK is required to create custom ISOs."
            Write-Host "Please install Windows ADK manually:"
            Write-Host "Download from: https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install"
            Write-Host "Only the 'Deployment Tools' component is required."
            exit 1
        }
    }
}

Write-Host "=== AlmaLinux Custom ISO Creator ==="
Write-Host "Original ISO: $originalISO"
Write-Host "Kickstart: $kickstartFile ($KickstartVersion)"
Write-Host "Target Generation: $Generation"
Write-Host "Output ISO: $customISO"
Write-Host "=====================================`n"

try {
    # Clean up previous work
    if (Test-Path $workDir) {
        Remove-Item $workDir -Recurse -Force
    }
    if (Test-Path $customISO) {
        Remove-Item $customISO -Force
    }
    
    # Create directories
    New-Item -ItemType Directory -Path $outputDir, $workDir, $extractDir -Force | Out-Null
    
    Write-Host "Extracting original ISO..."
    # Mount the original ISO
    $mountResult = Mount-DiskImage -ImagePath $originalISO -PassThru
    $driveLetter = ($mountResult | Get-Volume).DriveLetter
    
    # Copy all files from ISO
    robocopy "${driveLetter}:" $extractDir /E /NP /NJH /NJS | Out-Null
    
    # Dismount the original ISO
    Dismount-DiskImage -ImagePath $originalISO
    
    Write-Host "Copying kickstart file..."
    # Copy kickstart file to ISO root
    Copy-Item $kickstartFile "$extractDir\ks.cfg"
    
    Write-Host "Modifying boot configuration..."
    
    # Determine kickstart location based on generation
    if ($Generation -eq 1) {
        $ksLocation = "cdrom:/ks.cfg"
        $console = "console=tty0 console=ttyS0,115200"
    } else {
        $ksLocation = "cdrom:/ks.cfg"
        $console = "console=tty0 console=ttyS0,115200"
    }
    
    $bootParams = "inst.ks=$ksLocation inst.text $console rd.debug rd.udev.debug"
    
    # Modify BIOS boot configuration (isolinux)
    $isolinuxCfg = Join-Path $extractDir "isolinux\isolinux.cfg"
    if (Test-Path $isolinuxCfg) {
        Write-Host "Modifying BIOS boot configuration..."
        $content = Get-Content $isolinuxCfg
        
        # Find and modify the default install entry
        $modified = $false
        for ($i = 0; $i -lt $content.Count; $i++) {
            if ($content[$i] -match '^\s*append\s+.*vmlinuz') {
                # Add kickstart parameters to the kernel command line
                $content[$i] = $content[$i] + " $bootParams"
                $modified = $true
                Write-Host "  Modified BIOS boot entry: $($content[$i])"
            }
        }
        
        if ($modified) {
            Set-Content $isolinuxCfg $content
        } else {
            Write-Warning "Could not find BIOS boot entry to modify"
        }
    }
    
    # Modify UEFI boot configuration (grub)
    $grubCfg = Join-Path $extractDir "EFI\BOOT\grub.cfg"
    if (Test-Path $grubCfg) {
        Write-Host "Modifying UEFI boot configuration..."
        $content = Get-Content $grubCfg
        
        # Find and modify the linux boot entries
        $modified = $false
        for ($i = 0; $i -lt $content.Count; $i++) {
            if ($content[$i] -match '^\s*linux\s+.*vmlinuz') {
                # Add kickstart parameters to the kernel command line
                $content[$i] = $content[$i] + " $bootParams"
                $modified = $true
                Write-Host "  Modified UEFI boot entry: $($content[$i])"
            }
        }
        
        if ($modified) {
            Set-Content $grubCfg $content
        } else {
            Write-Warning "Could not find UEFI boot entry to modify"
        }
    }
    
    # Also check for grub.cfg in other locations
    $grubCfg2 = Join-Path $extractDir "boot\grub2\grub.cfg"
    if (Test-Path $grubCfg2) {
        Write-Host "Modifying additional GRUB configuration..."
        $content = Get-Content $grubCfg2
        
        for ($i = 0; $i -lt $content.Count; $i++) {
            if ($content[$i] -match '^\s*linux\s+.*vmlinuz') {
                $content[$i] = $content[$i] + " $bootParams"
                Write-Host "  Modified GRUB2 boot entry: $($content[$i])"
            }
        }
        
        Set-Content $grubCfg2 $content
    }
    
    Write-Host "Creating custom ISO..."
    # Create the custom ISO using oscdimg with proper UEFI/BIOS hybrid support
    $oscdimgArgs = @(
        "-n"                    # Allow long file names
        "-m"                    # Ignore maximum image size limit
        "-h"                    # Include hidden files
        "-l"                    # Long file name support
        "-j2"                   # Use Joliet file system level 2
        "-o"                    # Optimize layout
    )
    
    # Check for both BIOS and UEFI boot files
    $hasBiosBooter = Test-Path "$extractDir\isolinux\isolinux.bin"
    $hasUefiBooter = Test-Path "$extractDir\EFI\BOOT\bootx64.efi"
    
    if ($hasBiosBooter -and $hasUefiBooter) {
        # Hybrid BIOS/UEFI ISO - this is what we want for maximum compatibility
        Write-Host "Creating hybrid BIOS/UEFI bootable ISO..."
        $oscdimgArgs += "-b$extractDir\isolinux\isolinux.bin"
        $oscdimgArgs += "-c$extractDir\isolinux\boot.cat"
        # Note: oscdimg doesn't directly support dual boot like xorriso, but we include UEFI files
        # The UEFI boot files will be present and should work when booted in UEFI mode
    }
    elseif ($hasBiosBooter) {
        # BIOS-only ISO
        Write-Host "Creating BIOS bootable ISO..."
        $oscdimgArgs += "-b$extractDir\isolinux\isolinux.bin"
        $oscdimgArgs += "-c$extractDir\isolinux\boot.cat"
    }
    elseif ($hasUefiBooter) {
        # UEFI-only ISO (less common for Linux distros)
        Write-Host "Creating UEFI bootable ISO..."
        # oscdimg doesn't have direct UEFI-only support, but we'll create it anyway
    }
    else {
        Write-Warning "No bootable files found - creating non-bootable data ISO"
    }
    
    # Add source and destination
    $oscdimgArgs += $extractDir
    $oscdimgArgs += $customISO
    
    $result = & $oscdimgPath @oscdimgArgs 2>&1
    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "Failed to create ISO. oscdimg output: $result"
        throw "ISO creation failed with exit code $LASTEXITCODE"
    }
    
    Write-Host "Custom ISO created successfully: $customISO"
    Write-Host "ISO size: $([math]::Round((Get-Item $customISO).Length / 1MB, 2)) MB"
    
    # Cleanup
    Remove-Item $workDir -Recurse -Force
    
    Write-Host "`n=== Custom ISO Information ==="
    Write-Host "File: $customISO"
    Write-Host "Kickstart: Embedded as /ks.cfg"
    Write-Host "Boot Parameters: $bootParams"
    Write-Host "Generation: $Generation ($(if($Generation -eq 1){'BIOS'}else{'UEFI'}))"  
    
    Write-Host "`n=== Usage Instructions ==="
    Write-Host "1. Update config.yaml to use this custom ISO:"
    Write-Host "   iso_path: \"$customISO\""
    Write-Host "2. Run provision-vms.ps1 normally"
    Write-Host "3. VMs will boot and install automatically without manual intervention"
    Write-Host "4. No need to press TAB or add boot parameters manually"
    
    Write-Host "`nCustom ISO creation completed successfully!"
    
} catch {
    Write-Error "Failed to create custom ISO: $($_.Exception.Message)"
    
    # Cleanup on failure
    if (Test-Path $workDir) {
        Remove-Item $workDir -Recurse -Force -ErrorAction SilentlyContinue
    }
    if (Test-Path $customISO) {
        Remove-Item $customISO -Force -ErrorAction SilentlyContinue
    }
    
    exit 1
}
